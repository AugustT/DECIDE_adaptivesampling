---
title: "DECIDE Score"
author: "Thomas MM; Tom A"
date: "4/8/2021"
output: html_document
---

```{r setup, include=FALSE, echo = FALSE}

knitr::opts_chunk$set(echo = TRUE)

library(spatstat)



```

## Load species data

```{r species_data}

model = c('rf', 'lr', 'gam')
taxa = 'moth'

# get a list of all the species that appear in the outputs
spp_names_lr <- unique(gsub(pattern="lr_SDMs_|_meanpred.grd|_quantilemaxmin.grd|_quantilerange.grd", replacement = '', 
                            x = list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/lr'), pattern = '.grd')))

spp_names_rf <- unique(gsub(pattern="rf_SDMs_|_meanpred.grd|_quantilemaxmin.grd|_quantilerange.grd", replacement = '', 
                            x = list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/rf'), pattern = '.grd')))

spp_names_gam <- unique(gsub(pattern="gam_SDMs_|_meanpred.grd|_quantilemaxmin.grd|_quantilerange.grd", replacement = '', 
                             x = list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/gam'), pattern = '.grd')))

names <- unique(c(spp_names_lr, spp_names_rf, spp_names_gam))

# sdm outputs for each species
species_stack <- list()

# error outputs
error_out <- list()

for(i in 1:length(names)){
  
  print(names[i])
  
  # initiate model list within for loop so that it gets replaced when starting a new species
  # otherwise we might get some weird overlaps
  model_stack <- list()
  errored_models <- list()
  
  for(m in 1:length(model)){
    
    check_models <- list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/', model[m]), 
                               pattern = paste0(names[i]),
                               full.names = TRUE)
    
    if(length(check_models)<=1){
      
      print(paste('!!!   model', model[m], 'failed for species', names[i], '  !!!'))
      
      errored_models[[m]] <- data.frame(taxa = taxa, 
                                        species = names[i], 
                                        model = model[m])
      
      next
    }
    
    # mean predictions
    mp <- list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/', model[m]), 
                     pattern = paste0(names[i], "_meanpred.grd"),
                     full.names = TRUE)
    
    mod_preds <- raster::stack(mp)
    names(mod_preds) <- paste0(names[i], '_', model[m],'_mean_pred')
    
    
    
    # quantile min/max
    mm <- list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/', model[m]), 
                     pattern = paste0(names[i], "_quantilemaxmin.grd"),
                     full.names = TRUE)
    
    qminmax <- raster::stack(mm)
    names(qminmax) <- c(paste0(names[i], '_', model[m],'_min'), paste0(names[i], '_', model[m],'_max'))
    
    
    # quantile range
    qr <- list.files(paste0('/data-s3/thoval/sdm_outputs/', taxa, '/', model[m]), 
                     pattern = paste0(names[i], "_quantilerange.grd"),
                     full.names = TRUE)
    
    qrange <- raster::stack(qr)
    names(qrange) <- paste0(names[i], '_', model[m], '_quantile_range')
    
    
    # stack all from one model together
    model_stack[[m]] <- raster::stack(mod_preds, qminmax, qrange)
    
  }
  
  # model_stack[sapply(model_stack,is.null)] <- raster(nrow=12500, 
  #                                                    ncol=7000,
  #                                                    crs="+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs")
  
  # To combine them together need to remove the NULL raster layers (i.e. if a model hasn't worked)
  model_stack <- model_stack[!sapply(model_stack,is.null)]
  
  species_stack[[i]] <- raster::stack(model_stack)
  
  # Output the models that failed too
  error_out[[i]] <- do.call('rbind', errored_models) 
  
}

# which models didn't work
errors <- do.call('rbind', error_out)
errors

```


## Create a moth counts raster


```{r counts, echo=FALSE}

##  create a 'counts' raster layer  
dfm <- read.csv('Data/species_data/moth/DayFlyingMoths_East_Norths.csv')
head(dfm)

xy <- dfm[,c("lon","lat")]
spdf.moth <- SpatialPointsDataFrame(coords = xy, data = dfm,
                                    proj4string = CRS("+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs")) 

# plot(spdf.moth) ## check with plot

### create temporary raster to store number of records in each cell ###
moth_counts <- species_stack[[1]][[1]] # get a single raster

# make a raster of zeroes for input
moth_counts[!is.na(moth_counts)] <- 0

# get the cell index for each point and make a table:
counts = table(cellFromXY(moth_counts,spdf.moth))

# fill in the raster with the counts from the cell index:
moth_counts[as.numeric(names(counts))] <- counts
plot(moth_counts)
hist(moth_counts) ## loads of cells with no counts in so probably useless as a layer

```


loads of cells with no counts in so probably useless as a layer


## kernel density


```{r kern_dens}

sigma = 10000 # decide number of metres to calculate points over

moth_ppp <- ppp(x = dfm[,c("lon")], y = dfm[,c("lat")],
                owin(xrange = c(extent(moth_counts)[1], extent(moth_counts)[2]),
                     yrange = c(extent(moth_counts)[3], extent(moth_counts)[4])))


dp <- density(moth_ppp, sigma = sigma) 
dpr <- raster(dp)
re_dpr <- resample(dpr, moth_counts, method = 'ngb')
kernel_moth <- mask(re_dpr, moth_counts) # mask to remove sea
plot(kernel_moth)

kern_dens <- function(data, sigma, rast){
  
  
  moth_ppp <- ppp(x = data[,c("lon")], y = data[,c("lat")],
                  owin(xrange = c(extent(rast)[1], extent(rast)[2]),
                       yrange = c(extent(rast)[3], extent(rast)[4])))
  
  
  dp <- density(moth_ppp, sigma = sigma) 
  dpr <- raster(dp)
  re_dpr <- resample(dpr, rast, method = 'ngb')
  kernel_moth <- mask(re_dpr, rast) # mask to remove sea
  
}


for(i in c(1000, 5000, 10000, 20000)){
  
  out <- kern_dens(data = dfm, rast = moth_counts, sigma = i)
  
  plot(out, main = paste('grouping distance =', i))
  
}


```











