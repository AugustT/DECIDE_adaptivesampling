---
title: "Providing DECIDE nudges"
author: "Thomas MM; Tom A"
date: "6/1/2021"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(raster)
library(patchwork)


source("../../Scripts/modules/filter_distance.R")
source("../../Scripts/modules/convert_raster.R")
source("../../Scripts/modules/nudge_thin.R")
source("../../Scripts/modules/nudge_select.R")
source("../../Scripts/modules/nudge_list.R")
source("../../Scripts/modules/nudge_accessible.R")
source("../../Scripts/modules/load_gridnumbers.R")


```


We are going to run through some potential ideas for how the DECIDE score can be translated into nudges that can be suggested to people. The nudging process essentially follows these steps:

1. List of nudges that exceed a user-determined quantile for a given area
2. Select a user-determined subset of these nudges
3. Determine which nudges are near to accessible areas
4. Thin the nudges based on a user-defined grid

First, need to prepare the raster data for use; load it in and filter to a location. In this case, the location is 5km around Wallingford

```{r dec_rast, message = FALSE, warning = FALSE}

mgb <- raster('../../Data/species_data/decide_scores/moth_weighted_prob_pres_GB_decide_score.grd')


location = c(-1.110557, 51.602436) # wallingford
# location = c(-2.730696, 54.026759) # quernmore
distance = 5000

# crop
wall_m <- filter_distance(mgb,
                          location=location,
                          distance=distance,
                          method = 'buffer')

```

### 1. get a list of all nudges

To get a list of potential nudge locations we use the function **'nudge_list'**. This takes the raster we created above and converts it to a data frame. We can provide the function with a quantile value and a cutoff 'TRUE/FALSE' statement. The function identifies the values that exceed the quantile for the area of interest (defined by 'cutoff_value') and, if cutoff = TRUE, it will remove all the points falling below it. If cutoff = FALSE, it retains all the values irrespective of their score. The function **returns a data frame of potential nudge locations** whose length is determined by 'prop'; it's value defines the proportion of the total number of cells in an area that we want returned. The values can be weighted by the DECIDE score value, so that locations with high decide scores are preferentially selected. These values are often low, so I have inflated the effect of the DECIDE score by providing an inflation factor ('weight_inflation').

Below are some examples of the effects of the different parameters on the nudges returned; in these cases, changing the weightings when cutoff = TRUE/FALSE. NB if cutoff = FALSE and weight = FALSE, the function will return a random subset of background points.

```{r nudge_list_df_plots, echo = TRUE}

nud_prop01_cut_F <-  nudge_list(wall_m,
                                prop = 0.01, 
                                cutoff_value = 0.9, 
                                cutoff = FALSE,
                                weight = TRUE,
                                weight_inflation = 50)


nud_prop01_cut_F_unweight <-  nudge_list(wall_m,
                                         prop = 0.01, 
                                         cutoff_value = 0.9, 
                                         cutoff = FALSE,
                                         weight = FALSE,
                                         weight_inflation = 50)

nud_prop01_cut_T <-  nudge_list(wall_m,
                                prop = 0.01, 
                                cutoff_value = 0.9, 
                                cutoff = TRUE,
                                weight = TRUE,
                                weight_inflation = 50)


nud_prop01_cut_T_unweight <-  nudge_list(wall_m,
                                         prop = 0.01, 
                                         cutoff_value = 0.9, 
                                         cutoff = TRUE,
                                         weight = FALSE,
                                         weight_inflation = 50)


```


```{r nudge_list_plots, echo = FALSE, message = FALSE, warning = FALSE, fig.width=12}

nl_p1 <- ggplot() +
  geom_sf(data = conv_rast(wall_m, 27700), aes(fill = layer), col = NA) +
  geom_point(data = nud_prop01_cut_F, aes(x=lon,y=lat, col='Weighted')) +
  geom_point(data = nud_prop01_cut_F_unweight, aes(x=lon,y=lat, col='Unweighted')) +
  
  scale_fill_continuous(type= 'viridis', name = 'DECIDE score') +
  scale_colour_manual(name = '', values = c('black', 'red')) +
  theme_bw() +
  labs(x='', y='', title = 'No cutoff')

nl_p2 <- ggplot() +
  geom_sf(data = conv_rast(wall_m, 27700), aes(fill = layer), col = NA) +
  geom_point(data = nud_prop01_cut_T, aes(x=lon,y=lat, col='Weighted')) +
  geom_point(data = nud_prop01_cut_T_unweight, aes(x=lon,y=lat, col='Unweighted')) +
  
  scale_fill_continuous(type= 'viridis', name = 'DECIDE score') +
  scale_colour_manual(name = '', values = c('black', 'red')) +
  theme_bw() +
  labs(x='', y='', title = 'With cutoff')

nl_p1 + nl_p2 + plot_layout(guides = 'collect')

```

Here is a new data frame of weighted nudges from above and below the 90th percentile to use with the later functions.

```{r nudge_list, echo=TRUE}

# get a list of potential nudge locations
nudges <- nudge_list(wall_m,
                     prop = 0.1, 
                     cutoff_value = 0.9, 
                     cutoff = FALSE,
                     weight = TRUE,
                     weight_inflation = 10)
head(nudges)


```


```{r nudge_list_plot, warning = FALSE, message = FALSE}

nl_p_nudge1 <- ggplot() +
  geom_sf(data = conv_rast(wall_m, 27700), aes(fill = layer), col = NA) +
  geom_point(data = nudges, aes(x=lon,y=lat, col='Weighted nudges'))  +
  
  scale_fill_continuous(type= 'viridis', name = 'DECIDE score') +
  scale_colour_manual(name = '', values = 'black') +
  theme_bw() +
  labs(x='', y='', title = 'All nudges') +
  theme(legend.margin=margin(t=-0.25,l=0.05,b=0.0,r=0.05, unit='cm')) 
nl_p_nudge1

```



### 2. Select a subset of these nudges

We can get a specific number of these nudges using the function 'nudge_select'. This takes the total number of nudges we want and samples the data frame outputted from the nudge_list function. The function nudge_select can also be weighted by the DECIDE score, which can be inflated by a user-determined amount, to return only the highest value locations. The reason this function is split from the last one is that I can imagine a user wanting to randomise the nudges they are sent. With the functions split, it means that we would only have to run 'nudge_select' as opposed to also running the 'nudge_list' function above when users want a new sample of nudges. Currently, the areas being shown are only within 5km of the user. However, 'nudge_list' is very likely to be slow with larger rasters because of the raster::as.data.frame function (although I haven't directly tested this yet). The 'all nudges' plot is the same as the previous plot and is being compared to the 100 nudges sampled from it weighted by the DECIDE score.


```{r nudge_subset}

nudge_subset <- nudge_select(nudge_df = nudges, 
                             n = 100,
                             cutoff = FALSE,
                             weight = TRUE,
                             weighting_column = 'dec_score',
                             weight_inflation = 10)


```

```{r nudge_subset_plot, warning=FALSE, fig.width=11}


nl_p_nudge2 <- ggplot() +
  geom_sf(data = conv_rast(wall_m, 27700), aes(fill = layer), col = NA) +
  geom_point(data = nudge_subset, aes(x=lon,y=lat, col='Weighted nudges subset'))  +
  
  scale_fill_continuous(type= 'viridis', name = 'DECIDE score') +
  scale_colour_manual(name = '', values = 'red') +
  theme_bw() +
  labs(x='', y='', title = 'Subsetted nudges') + 
  theme(legend.margin=margin(t=-0.25,l=0.05,b=0.0,r=0.05, unit='cm')) 

nl_p_nudge1 + nl_p_nudge2 + plot_layout(guides = 'collect')

```



### 3. Find nudges close to accessible areas

We need to find the nudges that are actually accessible to the user. For this, we can use the 'nudge_accessible' function. It takes an sf dataframe of nudges,  accessible areas (i.e. footpaths etc.) and a buffer distance, and returns all the nudges that fall within this region.

```{r load_access_locs, echo = F, message = F, warning = F}

## function to choose points close to accessible features 

# first load the accessible areas

# load a UK grid - currently 10km
grid <- st_read('/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/UK_grids/uk_grid_10km.shp')
st_crs(grid) <- 27700

# find grid numbers that location + buffered zone covers
grid_numbers <- load_gridnumbers(location = location,
                                 distance = distance,
                                 grid = grid)

# shape data
# point to shape locations - move data to a common directory
{# england
  prow_loc <- ("/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/rowmaps_footpathbridleway/rowmaps_footpathbridleway/gridded_data_10km/")
  grnspc_loc <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/OS_greenspaces/OS Open Greenspace (ESRI Shape File) GB/data/gridded_greenspace_data_10km/"
  accspnt_loc <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/OS_greenspaces/OS Open Greenspace (ESRI Shape File) GB/data/gridded_accesspoint_data_10km/"
  access_land_loc <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/CRoW_Act_2000_-_Access_Layer_(England)-shp/gridded_data_10km/"
  nat_trust_loc <- '/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/national_trust/gridded_data_10km/'
  lond_path_loc <- '/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/greater-london-latest-free/london_gridded_data_10km/'
  
  
  # scotland
  core_paths <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/core_paths/gridded_data_10km/"
  pub_acc <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/public_access_wiat/gridded_data_10km/"
  cairn <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/cairngorms/gridded_data_10km/"
  tross <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/lochlomond_tross/gridded_data_10km/"
  cons_sites <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/local_nature_conservation_sites/gridded_data_10km/"
  nat_sites <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/local_nature_reserves/gridded_data_10km/"
  wild <- "/data/notebooks/rstudio-setupconsthomas/DECIDE_constraintlayers/Data/raw_data/Scotland/wildland_scotland/gridded_data_10km/"
}

# extract shapes for location of interest
system.time(
  acc_loc <- lapply(c(1:length(grid_numbers)), FUN = function(n){
    
    
    ####    ENGLAND    ####
    # prow .shp
    prow_files <- list.files(prow_loc,
                             full.names = T,
                             pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(prow_files) != 0) {
      prow <- sf::st_read(prow_files, quiet = TRUE)
      st_crs(prow) <- 27700
    } else { prow <- NULL }
    
    # greenspaces .shp
    grnspc_files <- list.files(grnspc_loc,
                               full.names = T,
                               pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(grnspc_files) != 0){
      grnspc <- sf::st_read(grnspc_files, quiet = TRUE)
      st_crs(grnspc) <- 27700
    } else { grnspc <- NULL }
    
    # access points .shp
    accs_files <- list.files(accspnt_loc,
                             full.names = T,
                             pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(accs_files) != 0){
      accspnt <- sf::st_read(accs_files, quiet = TRUE)
      st_crs(accspnt) <- 27700
    } else{ accspnt <- NULL }
    
    # access land .shp
    accslnd_files <- list.files(access_land_loc,
                                full.names = T,
                                pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(accslnd_files) != 0){
      accslnd <- sf::st_read(accslnd_files, quiet = TRUE)
      st_crs(accslnd) <- 27700
    } else { accslnd <- NULL }
    
    # national trust .shp
    national_trust_files <- list.files(nat_trust_loc,
                                       full.names = T,
                                       pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(national_trust_files) != 0){
      national_trust <- sf::st_read(national_trust_files, quiet = TRUE)
      st_crs(national_trust) <- 27700
    } else { national_trust <- NULL }
    
    # london shapes .shp
    london_files <- list.files(lond_path_loc,
                               full.names = T,
                               pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(london_files) != 0){
      london_paths <- sf::st_read(london_files, quiet = TRUE)
      st_crs(london_paths) <- 27700
    } else { london_paths <- NULL }
    
    
    ####    SCOTLAND    ####
    
    # core paths
    cp_files <- list.files(core_paths,
                           full.names = T,
                           pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(cp_files) != 0){
      c_paths <- sf::st_read(cp_files, quiet = TRUE)
      st_crs(c_paths) <- 27700
    } else { c_paths <- NULL }
    
    
    # public access
    # paths
    pacc_path_files <- list.files(pub_acc,
                                  full.names = T,
                                  pattern = paste0('paths_gridnumber_', grid_numbers[n], '.shp'))
    
    if(length(pacc_path_files) != 0){
      pacc_paths <- sf::st_read(pacc_path_files, quiet = TRUE)
      st_crs(pacc_paths) <- 27700
    } else { pacc_paths <- NULL }
    
    # woods
    pacc_wood_files <- list.files(pub_acc,
                                  full.names = T,
                                  pattern = paste0('wood_gridnumber_', grid_numbers[n], '.shp'))
    
    if(length(pacc_wood_files) != 0){
      pacc_wood <- sf::st_read(pacc_wood_files, quiet = TRUE)
      st_crs(pacc_wood) <- 27700
    } else { pacc_wood <- NULL }
    
    
    ## national parks
    # cairngorm
    cairn_files <- list.files(cairn,
                              full.names = T,
                              pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(cairn_files) != 0){
      cairn_shp <- sf::st_read(cairn_files, quiet = TRUE)
      st_crs(cairn_shp) <- 27700
    } else { cairn_shp <- NULL }
    
    
    # trossacks
    tross_files <- list.files(tross,
                              full.names = T,
                              pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(tross_files) != 0){
      tross_shp <- sf::st_read(tross_files, quiet = TRUE)
      st_crs(tross_shp) <- 27700
    } else { tross_shp <- NULL }
    
    
    # conservation sites
    cons_files <- list.files(cons_sites,
                             full.names = T,
                             pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(cons_files) != 0){
      cons_shp <- sf::st_read(cons_files, quiet = TRUE)
      st_crs(cons_shp) <- 27700
    } else { cons_shp <- NULL }
    
    
    # natural conservation sites
    nat_files <- list.files(nat_sites,
                            full.names = T,
                            pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(nat_files) != 0){
      nat_shp <- sf::st_read(nat_files, quiet = TRUE)
      st_crs(nat_shp) <- 27700
    } else { nat_shp <- NULL }
    
    
    # wildland sites
    wild_files <- list.files(wild,
                             full.names = T,
                             pattern = paste0('_', grid_numbers[n], '.shp'))
    
    if(length(wild_files) != 0){
      wild_shp <- sf::st_read(wild_files, quiet = TRUE)
      st_crs(wild_shp) <- 27700
    } else { wild_shp <- NULL }
    
    return(list(prow, grnspc, accspnt, accslnd, national_trust, london_paths, ## england
                c_paths, pacc_paths, pacc_wood, cairn_shp, tross_shp, cons_shp, nat_shp, wild_shp)) ## scotland
    
  })
)

all_outs <- do.call(Map, c(rbind, acc_loc))

# crop shapes to exact region of interest
final_acc_loc <- lapply(all_outs, filter_distance,
                        location = location,
                        distance = distance,
                        method = 'buffer')



```


```{r nudge_accessible}


accessible_nudges <- nudge_accessible(nudges_df = nudge_subset,
                                      access_layers = final_acc_loc,
                                      buffer = 200,
                                      crs = 27700,
                                      lon = 'lon',
                                      lat = 'lat',
                                      plot = TRUE)


```

### 4. Thin the nudges

There is unlikely to be much point in providing the user with nudges that are very close together. The function 'nudge_thin' creates a grid whose resolution is defined by the user and samples from the points within each of the grid cels. The user also states how many points to sample from each grid and can specify whether to use a square or hexagonal grid (the latter being better for large areas). This uses the original raster layer and the 'nudge_select' function (although will also work with the 'nudge_list' function) and provides as output: a data frame with the thinned nudges, the grid as an sf object and the plot. The plot takes a while to produces (a few seconds), but obviously won't need to be produced for the app.


```{r thin_nudge, warning = FALSE, message = FALSE, echo = T}


thinned_nudges <- nudge_thin(decide_raster = wall_m,
                             nudge_df = accessible_nudges$nudges,
                             lon = 'lon',
                             lat = 'lat',
                             crs = 27700, 
                             buffer_distance = 1000,
                             sample_num = 1)

thinned_nudges$plot

```

### "Final" nudges

```{r final_nudges, message = FALSE, warning = FALSE}

ggplot() +
  geom_sf(data = conv_rast(wall_m, 27700), aes(fill=layer), colour = NA) +
  geom_sf(data = thinned_nudges$nudges, aes(colour = 'Suggested sampling\nlocations')) +
  scale_fill_continuous(type = 'viridis', name = 'DECIDE score') +
  scale_colour_manual(name = '', values = 'red') +
  theme_bw()


```








